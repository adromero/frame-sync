<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrameSync</title>
    <!-- Version: 2025-11-23-mobile-improvements -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }

        .upload-area {
            border: 3px dashed #14b8a6;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f0fdfa;
        }

        .upload-area:hover {
            border-color: #0d9488;
            background: #ccfbf1;
        }

        .upload-area.dragover {
            border-color: #0d9488;
            background: #99f6e4;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #0d9488;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #888;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(20, 184, 166, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            padding: 8px 20px;
            font-size: 0.9em;
        }

        .btn-success {
            background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
            padding: 8px 20px;
            font-size: 0.9em;
        }

        .message {
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
        }

        .message.success {
            background: #d3f9d8;
            color: #2b8a3e;
            border: 1px solid #51cf66;
        }

        .message.error {
            background: #ffe3e3;
            color: #c92a2a;
            border: 1px solid #ff6b6b;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .image-card {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
        }

        .image-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .image-card.current {
            border: 3px solid #51cf66;
        }

        .image-card.selected {
            border: 3px solid #4dabf7;
            background: #e7f5ff;
        }

        .image-checkbox {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 10;
            accent-color: #4dabf7;
        }

        .bulk-toolbar {
            display: none;
            background: white;
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .bulk-toolbar.active {
            display: flex;
        }

        .bulk-toolbar-label {
            font-weight: 600;
            color: #333;
            margin-right: auto;
        }

        .bulk-toolbar-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-bulk {
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .image-thumbnail {
            width: 100%;
            height: 150px;
            object-fit: cover;
            background: #f0f0f0;
        }

        /* Lazy loading skeleton */
        .image-thumbnail.lazy-loading {
            background: linear-gradient(
                90deg,
                #f0f0f0 25%,
                #e0e0e0 50%,
                #f0f0f0 75%
            );
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }

        .image-thumbnail.lazy-loaded {
            animation: fadeIn 0.5s ease-in;
        }

        .image-info {
            padding: 10px;
        }

        .image-name {
            font-weight: 600;
            margin-bottom: 5px;
            word-break: break-all;
            font-size: 0.75em;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .current-badge {
            background: #51cf66;
            color: white;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75em;
            font-weight: 600;
            margin-bottom: 10px;
            display: inline-block;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(20, 184, 166, 0.3);
            border-radius: 50%;
            border-top-color: #14b8a6;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .filter-section {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-section label {
            font-weight: 600;
            color: #333;
        }

        .filter-select {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .filter-select:hover {
            border-color: #14b8a6;
        }

        .filter-select:focus {
            outline: none;
            border-color: #14b8a6;
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
        }

        .user-ip-badge {
            background: #ccfbf1;
            color: #0f766e;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .uploader-badge {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
            margin-bottom: 8px;
            display: inline-block;
        }

        .uploader-badge.other {
            background: #fff3e0;
            color: #e65100;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
            animation: slideIn 0.3s;
        }

        .modal-close {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 30px;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            z-index: 1001;
            background: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .modal-close:hover {
            color: #000;
        }

        .modal-image-container {
            padding: 20px;
            text-align: center;
        }

        .modal-image {
            max-width: 100%;
            max-height: 60vh;
            border-radius: 10px;
        }

        .modal-details {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        /* Name input section */
        .name-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .name-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }

        .name-input:focus {
            outline: none;
            border-color: #14b8a6;
        }

        .btn-edit {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }

        /* Loading spinner on buttons */
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
            margin-right: 5px;
        }

        /* Footer styles */
        .footer {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            text-align: center;
        }

        .footer h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .ip-list {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .ip-item {
            background: #ccfbf1;
            padding: 12px 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 100%;
        }

        .ip-label {
            font-weight: 600;
            color: #0f766e;
        }

        .ip-value {
            font-family: monospace;
            font-size: 1.1em;
            color: #333;
            word-break: break-all;
            max-width: 400px;
        }

        .copy-btn {
            background: #14b8a6;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        .copy-btn:hover {
            background: #0d9488;
        }

        .copy-btn.copied {
            background: #51cf66;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #uploadDeviceSelection {
            animation: slideDown 0.4s ease-out;
        }

        /* Devices styles */
        .devices-list {
            margin-bottom: 15px;
        }

        .device-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: #f8f9ff;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 2px solid #e0e0e0;
        }

        .device-info {
            flex: 1;
        }

        .device-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .device-meta {
            font-size: 0.85em;
            color: #888;
        }

        .device-type-badge {
            background: #14b8a6;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            margin-right: 8px;
        }

        .device-id {
            font-family: monospace;
            font-size: 0.75em;
            color: #999;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        .device-id:hover {
            color: #14b8a6;
        }

        .device-id.expanded {
            word-break: break-all;
        }

        .btn-small {
            padding: 6px 15px;
            font-size: 0.85em;
        }

        .modal-devices-list {
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
            background: #f8f9ff;
        }

        .device-checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .device-checkbox-item:hover {
            background: #e8ebff;
        }

        .device-checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .device-checkbox-label {
            flex: 1;
            cursor: pointer;
            user-select: none;
        }

        @media (max-width: 1024px) {
            .gallery {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .gallery {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 2em;
            }

            .gallery {
                grid-template-columns: repeat(2, 1fr);
            }

            .filter-section {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-select {
                min-width: 100%;
            }

            .ip-list {
                flex-direction: column;
            }

            .name-section {
                flex-direction: column;
                align-items: stretch;
            }

            .ip-value {
                font-size: 0.9em;
                max-width: 100%;
            }

            /* Mobile-specific device improvements */
            .device-item {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .device-info {
                width: 100%;
            }

            .device-name {
                font-size: 0.95em;
            }

            .device-meta {
                font-size: 0.8em;
                word-break: break-word;
            }

            .device-id {
                font-size: 0.7em;
            }

            .btn-small {
                width: 100%;
            }

            /* Bulk toolbar on mobile */
            .bulk-toolbar {
                flex-direction: column;
                align-items: stretch;
            }

            .bulk-toolbar-label {
                margin-bottom: 10px;
                text-align: center;
            }

            .bulk-toolbar-actions {
                width: 100%;
            }

            .btn-bulk {
                flex: 1;
                min-width: 0;
            }

            /* Modal actions on mobile */
            .modal-actions {
                flex-wrap: wrap;
            }

            .modal-actions .btn {
                flex: 1 1 calc(50% - 5px);
                min-width: 0;
                padding: 10px 8px;
                font-size: 0.85em;
            }
        }

        /* Pagination styles */
        .pagination-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
        }

        .pagination-btn {
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .pagination-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(20, 184, 166, 0.4);
        }

        .pagination-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .page-info {
            color: white;
            font-size: 1em;
            font-weight: 500;
        }

        /* Progress bar styles */
        .progress-container {
            margin-top: 15px;
            display: none;
        }

        .progress-bar-wrapper {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
        }

        .progress-text {
            margin-top: 8px;
            text-align: center;
            color: #0d9488;
            font-weight: 600;
            font-size: 0.95em;
        }

        /* Storage quota styles */
        .storage-info {
            background: linear-gradient(135deg, #f0fdfa 0%, #ccfbf1 100%);
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 15px;
            border: 2px solid #14b8a6;
        }

        .storage-info.warning {
            background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);
            border-color: #f97316;
        }

        .storage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .storage-title {
            font-weight: 600;
            color: #0d9488;
            font-size: 0.95em;
        }

        .storage-info.warning .storage-title {
            color: #c2410c;
        }

        .storage-text {
            color: #0f766e;
            font-size: 0.9em;
        }

        .storage-info.warning .storage-text {
            color: #9a3412;
        }

        .storage-bar-wrapper {
            width: 100%;
            height: 20px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-top: 10px;
        }

        .storage-bar {
            height: 100%;
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.75em;
        }

        .storage-info.warning .storage-bar {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>FrameSync</h1>
            <p>Sync and display photos across all your devices</p>
        </div>

        <div class="card">
            <div id="storageInfo" class="storage-info" style="display: none;">
                <div class="storage-header">
                    <span class="storage-title">ðŸ’¾ Storage Usage</span>
                    <span class="storage-text" id="storageText">Loading...</span>
                </div>
                <div class="storage-bar-wrapper">
                    <div id="storageBar" class="storage-bar" style="width: 0%;">0%</div>
                </div>
            </div>
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ðŸ“·</div>
                <div class="upload-text">Click or drag image here to upload</div>
                <div class="upload-hint">Supports PNG, JPG, GIF, and BMP (max 16MB)</div>
                <input type="file" id="fileInput" accept="image/*" multiple>
            </div>
            <div id="uploadDeviceSelection" style="display: none; margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%); border-radius: 12px; border: 3px solid #14b8a6; box-shadow: 0 4px 15px rgba(20, 184, 166, 0.3);">
                <h3 style="margin: 0 0 15px 0; font-size: 1.1em; color: #0d9488; font-weight: 700;">ðŸ“± Select Displays for Upload</h3>
                <p style="margin: 0 0 15px 0; color: #0f766e; font-size: 0.9em;">Choose which devices should receive these images:</p>
                <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: 700; color: #0d9488; font-size: 1em;">
                        <input type="checkbox" id="selectAllDisplays" style="cursor: pointer; width: 20px; height: 20px;">
                        <span>âœ“ All Displays</span>
                    </label>
                    <button class="btn btn-small" id="clearPreferencesBtn" style="background: linear-gradient(135deg, #fb8c00 0%, #f57c00 100%); padding: 6px 14px; font-size: 0.85em; white-space: nowrap;" title="Clear saved device preferences">Clear Saved Preferences</button>
                </div>
                <div id="uploadDevicesList" style="display: grid; gap: 10px; max-height: 180px; overflow-y: auto; padding: 10px; background: white; border-radius: 8px;">
                    <!-- Device checkboxes will be populated here -->
                </div>
                <div style="margin-top: 20px; display: flex; gap: 12px; justify-content: flex-end;">
                    <button class="btn" id="cancelUploadBtn" style="background: linear-gradient(135deg, #999 0%, #777 100%); padding: 12px 25px; font-size: 1em;">Cancel</button>
                    <button class="btn" id="confirmUploadBtn" style="padding: 12px 30px; font-size: 1.05em; font-weight: 700; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.4);">Upload Images â†’</button>
                </div>
            </div>
            <div id="progressContainer" class="progress-container">
                <div class="progress-bar-wrapper">
                    <div id="progressBar" class="progress-bar">0%</div>
                </div>
                <div id="progressText" class="progress-text">Preparing upload...</div>
            </div>
            <div id="message" class="message"></div>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 15px;">Your Identity</h2>
            <div class="name-section">
                <span class="user-ip-badge" id="currentUserIp">Your IP: Loading...</span>
                <div id="nameDisplay" style="display: none;">
                    <span style="font-size: 1.1em; font-weight: 600; color: #333;" id="displayedName"></span>
                    <button class="btn btn-edit btn-small" id="editNameBtn">Change Name</button>
                </div>
                <div id="nameEditForm" style="display: none; flex: 1; min-width: 0;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <input type="text" id="nameInput" class="name-input" placeholder="Enter your name" maxlength="50" style="flex: 1; min-width: 150px;">
                        <button class="btn btn-edit" id="saveNameBtn">Save</button>
                        <button class="btn" id="cancelNameBtn" style="background: #999;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 15px;">Devices</h2>
            <p style="color: #666; margin-bottom: 15px; font-size: 0.9em;">Manage devices that can display photos. Each device needs a unique ID.</p>
            <div id="devicesList" class="devices-list">
                <div class="spinner"></div>
            </div>
            <div style="margin-top: 15px;">
                <input type="text" id="deviceNameInput" class="name-input" placeholder="Enter device name" maxlength="100">
                <button class="btn" id="addDeviceBtn">Add New Device</button>
            </div>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 15px;">Photo Gallery</h2>
            <div class="filter-section">
                <div style="flex: 1; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <div style="flex: 1; min-width: 200px;">
                        <input type="text" id="searchInput" class="name-input" placeholder="ðŸ” Search by filename..." style="width: 100%; padding: 10px; margin: 0;">
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <label for="userFilter" style="margin: 0;">Owner:</label>
                        <select id="userFilter" class="filter-select">
                            <option value="all">All Photos</option>
                            <option value="me">My Photos</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <label for="deviceFilter" style="margin: 0;">Device:</label>
                        <select id="deviceFilter" class="filter-select">
                            <option value="all">All Devices</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <label for="sortBySelect" style="margin: 0;">Sort:</label>
                        <select id="sortBySelect" class="filter-select">
                            <option value="upload_time">Upload Date</option>
                            <option value="date_taken">Date Taken</option>
                        </select>
                    </div>
                    <button class="btn btn-small" id="clearFiltersBtn" style="background: linear-gradient(135deg, #999 0%, #777 100%); white-space: nowrap;">Clear Filters</button>
                </div>
            </div>
            <div class="filter-section" style="margin-top: 10px;">
                <div style="flex: 1; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <label for="dateFromInput" style="margin: 0;">Date Range:</label>
                    <input type="date" id="dateFromInput" class="name-input" style="width: auto; padding: 8px; margin: 0;">
                    <span>to</span>
                    <input type="date" id="dateToInput" class="name-input" style="width: auto; padding: 8px; margin: 0;">
                </div>
            </div>
            <div id="bulkToolbar" class="bulk-toolbar">
                <span class="bulk-toolbar-label" id="bulkToolbarLabel">0 images selected</span>
                <div class="bulk-toolbar-actions">
                    <button class="btn btn-bulk" id="selectAllBtn" style="background: #4dabf7;">Select All</button>
                    <button class="btn btn-bulk" id="deselectAllBtn" style="background: #999;">Deselect All</button>
                    <button class="btn btn-bulk btn-danger" id="bulkDeleteBtn">Delete Selected</button>
                    <button class="btn btn-bulk btn-success" id="bulkChangeDevicesBtn">Change Devices</button>
                </div>
            </div>
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <div>Loading images...</div>
            </div>
            <div id="gallery" class="gallery"></div>
            <div id="paginationContainer" class="pagination-container" style="display: none;">
                <button id="prevPageBtn" class="pagination-btn">Previous</button>
                <div id="pageInfo" class="page-info"></div>
                <button id="nextPageBtn" class="pagination-btn">Next</button>
            </div>
        </div>

        <div class="footer">
            <h3>Share FrameSync</h3>
            <div class="ip-list" id="ipList">
                <div class="spinner"></div>
            </div>
        </div>
    </div>

    <!-- Modal for full-size image -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="modalClose">&times;</span>
            <div class="modal-image-container">
                <img id="modalImage" class="modal-image" src="" alt="">
            </div>
            <div class="modal-details">
                <h3 id="modalImageName"></h3>
                <p id="modalImageMeta"></p>
                <p id="modalImageUploader"></p>

                <!-- EXIF metadata section -->
                <div id="exifSection" style="margin: 15px 0; padding: 12px; background: #f8f9fa; border-radius: 8px; display: none;">
                    <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">Photo Information</h4>
                    <div style="font-size: 13px; color: #555; line-height: 1.8;">
                        <div id="exifDateTaken"></div>
                        <div id="exifCamera"></div>
                        <div id="exifLocation"></div>
                        <div id="exifDetails"></div>
                    </div>
                </div>

                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Allowed Devices:</label>
                    <div id="modalDevicesList" class="modal-devices-list">
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn" id="modalRotateLeftBtn" style="background: #06b6d4;" title="Rotate 90Â° counter-clockwise">â†º 90Â°</button>
                    <button class="btn" id="modalRotate180Btn" style="background: #0891b2;" title="Rotate 180Â°">â†» 180Â°</button>
                    <button class="btn" id="modalRotateRightBtn" style="background: #0e7490;" title="Rotate 90Â° clockwise">â†» 90Â°</button>
                    <button class="btn" id="modalSaveDevicesBtn" style="background: #28a745;">Save Devices</button>
                    <button class="btn btn-success" id="modalDisplayBtn">Display on Frame</button>
                    <button class="btn btn-danger" id="modalDeleteBtn">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for bulk device assignment -->
    <div id="bulkDeviceModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="modal-close" id="bulkDeviceModalClose">&times;</span>
            <div class="modal-details">
                <h3>Change Devices for Selected Images</h3>
                <p style="color: #666; margin: 10px 0;">Select which devices should display the <span id="bulkSelectionCount">0</span> selected images:</p>
                <div style="margin: 15px 0;">
                    <div id="bulkDevicesList" class="modal-devices-list">
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn" id="bulkDeviceModalCancel" style="background: #999;">Cancel</button>
                    <button class="btn btn-success" id="bulkDeviceModalSave">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const message = document.getElementById('message');
        const gallery = document.getElementById('gallery');
        const loading = document.getElementById('loading');
        const userFilter = document.getElementById('userFilter');
        const searchInput = document.getElementById('searchInput');
        const deviceFilter = document.getElementById('deviceFilter');
        const sortBySelect = document.getElementById('sortBySelect');
        const dateFromInput = document.getElementById('dateFromInput');
        const dateToInput = document.getElementById('dateToInput');
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        const currentUserIpEl = document.getElementById('currentUserIp');
        const nameInput = document.getElementById('nameInput');
        const saveNameBtn = document.getElementById('saveNameBtn');
        const nameDisplay = document.getElementById('nameDisplay');
        const nameEditForm = document.getElementById('nameEditForm');
        const displayedName = document.getElementById('displayedName');
        const editNameBtn = document.getElementById('editNameBtn');
        const cancelNameBtn = document.getElementById('cancelNameBtn');
        const imageModal = document.getElementById('imageModal');
        const modalClose = document.getElementById('modalClose');
        const modalImage = document.getElementById('modalImage');
        const modalImageName = document.getElementById('modalImageName');
        const modalImageMeta = document.getElementById('modalImageMeta');
        const modalImageUploader = document.getElementById('modalImageUploader');
        const modalDisplayBtn = document.getElementById('modalDisplayBtn');
        const modalDeleteBtn = document.getElementById('modalDeleteBtn');
        const modalRotateLeftBtn = document.getElementById('modalRotateLeftBtn');
        const modalRotate180Btn = document.getElementById('modalRotate180Btn');
        const modalRotateRightBtn = document.getElementById('modalRotateRightBtn');
        const ipList = document.getElementById('ipList');
        const devicesList = document.getElementById('devicesList');
        const deviceNameInput = document.getElementById('deviceNameInput');
        const addDeviceBtn = document.getElementById('addDeviceBtn');
        const modalDevicesList = document.getElementById('modalDevicesList');
        const modalSaveDevicesBtn = document.getElementById('modalSaveDevicesBtn');
        const paginationContainer = document.getElementById('paginationContainer');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const bulkToolbar = document.getElementById('bulkToolbar');
        const bulkToolbarLabel = document.getElementById('bulkToolbarLabel');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
        const bulkChangeDevicesBtn = document.getElementById('bulkChangeDevicesBtn');
        const bulkDeviceModal = document.getElementById('bulkDeviceModal');
        const bulkDeviceModalClose = document.getElementById('bulkDeviceModalClose');
        const bulkDeviceModalCancel = document.getElementById('bulkDeviceModalCancel');
        const bulkDeviceModalSave = document.getElementById('bulkDeviceModalSave');
        const bulkSelectionCount = document.getElementById('bulkSelectionCount');
        const bulkDevicesList = document.getElementById('bulkDevicesList');

        let currentImage = null;
        let currentPage = 1;
        let totalPages = 1;
        const itemsPerPage = 12;  // Show 12 images per page
        let currentUserIp = null;
        let currentUserName = null;
        let lastRotationTimestamp = Date.now();  // Track last rotation for cache busting
        let allDevices = [];
        let currentImageFilename = null;
        let currentModalImage = null;
        let pendingFiles = null;
        let selectedImages = new Set();  // Track selected image filenames for bulk operations

        // Modal event listeners
        modalClose.addEventListener('click', closeModal);
        imageModal.addEventListener('click', (e) => {
            if (e.target === imageModal) closeModal();
        });

        // Name management buttons
        saveNameBtn.addEventListener('click', saveUserName);
        editNameBtn.addEventListener('click', enterEditMode);
        cancelNameBtn.addEventListener('click', exitEditMode);
        nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveUserName();
        });

        // Click to upload
        uploadArea.addEventListener('click', () => fileInput.click());

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                // Store files and show device selection UI
                pendingFiles = files;
                const uploadDeviceSelection = document.getElementById('uploadDeviceSelection');
                uploadDeviceSelection.style.display = 'block';
                populateUploadDevicesList();
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                // Store files and show device selection UI
                pendingFiles = e.target.files;
                const uploadDeviceSelection = document.getElementById('uploadDeviceSelection');
                uploadDeviceSelection.style.display = 'block';
                populateUploadDevicesList();
            }
        });

        async function handleFiles(files) {
            for (let file of files) {
                await uploadFile(file);
            }

            // Hide device selection UI after upload
            const uploadDeviceSelection = document.getElementById('uploadDeviceSelection');
            uploadDeviceSelection.style.display = 'none';

            // Reset file input and pending files
            fileInput.value = '';
            pendingFiles = null;

            loadImages();
            loadUsers(); // Refresh user list after uploads
            loadStorageInfo(); // Refresh storage info after uploads
        }

        async function uploadFile(file) {
            return new Promise((resolve, reject) => {
                const formData = new FormData();
                formData.append('file', file);

                // Get selected devices
                const selectedDevices = getSelectedUploadDevices();
                if (selectedDevices.length > 0) {
                    formData.append('allowed_devices', JSON.stringify(selectedDevices));
                }

                const xhr = new XMLHttpRequest();

                // Show progress bar
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressText.textContent = `Uploading ${file.name}...`;

                // Progress event listener
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percentComplete + '%';
                        progressBar.textContent = percentComplete + '%';

                        const uploadedMB = (e.loaded / (1024 * 1024)).toFixed(2);
                        const totalMB = (e.total / (1024 * 1024)).toFixed(2);
                        progressText.textContent = `Uploading ${file.name}... ${uploadedMB}MB / ${totalMB}MB`;
                    }
                });

                // Load event listener (upload complete)
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const data = JSON.parse(xhr.responseText);

                            if (data.success) {
                                progressBar.style.width = '100%';
                                progressBar.textContent = '100%';
                                const deviceMsg = selectedDevices.length > 0 ? ` (enabled on ${selectedDevices.length} display${selectedDevices.length > 1 ? 's' : ''})` : '';
                                progressText.textContent = `${file.name} uploaded successfully!${deviceMsg}`;

                                showMessage(`${file.name} uploaded successfully!${deviceMsg}`, 'success');

                                // Update current user IP if we got it from the response
                                if (data.uploader_ip && !currentUserIp) {
                                    currentUserIp = data.uploader_ip;
                                    updateUserDisplay();
                                }

                                // Hide progress bar after 2 seconds
                                setTimeout(() => {
                                    progressContainer.style.display = 'none';
                                }, 2000);

                                resolve(data);
                            } else {
                                progressContainer.style.display = 'none';
                                const errorMsg = getErrorMessage(data);
                                showMessage(`Error: ${errorMsg}`, 'error');
                                reject(new Error(errorMsg));
                            }
                        } catch (error) {
                            progressContainer.style.display = 'none';
                            showMessage(`Failed to parse response: ${error.message}`, 'error');
                            reject(error);
                        }
                    } else {
                        progressContainer.style.display = 'none';
                        showMessage(`Upload failed with status: ${xhr.status}`, 'error');
                        reject(new Error(`HTTP ${xhr.status}`));
                    }
                });

                // Error event listener
                xhr.addEventListener('error', () => {
                    progressContainer.style.display = 'none';
                    showMessage(`Failed to upload: Network error`, 'error');
                    reject(new Error('Network error'));
                });

                // Abort event listener
                xhr.addEventListener('abort', () => {
                    progressContainer.style.display = 'none';
                    showMessage(`Upload cancelled`, 'error');
                    reject(new Error('Upload cancelled'));
                });

                // Open and send the request
                xhr.open('POST', '/api/upload');
                xhr.send(formData);
            });
        }

        function updateUserDisplay() {
            if (currentUserName) {
                currentUserIpEl.textContent = `Your IP: ${currentUserIp}`;
                displayedName.textContent = currentUserName;
                nameDisplay.style.display = 'flex';
                nameDisplay.style.gap = '10px';
                nameDisplay.style.alignItems = 'center';
                nameEditForm.style.display = 'none';
            } else if (currentUserIp) {
                currentUserIpEl.textContent = `Your IP: ${currentUserIp}`;
                nameDisplay.style.display = 'none';
                nameEditForm.style.display = 'flex';
            } else {
                currentUserIpEl.textContent = 'Your identity will be shown after first upload';
                nameDisplay.style.display = 'none';
                nameEditForm.style.display = 'none';
            }
        }

        function enterEditMode() {
            nameInput.value = currentUserName || '';
            nameDisplay.style.display = 'none';
            nameEditForm.style.display = 'flex';
            nameInput.focus();
        }

        function exitEditMode() {
            nameInput.value = '';
            updateUserDisplay();
        }

        async function saveUserName() {
            const name = nameInput.value.trim();
            if (!name) {
                showMessage('Please enter a name', 'error');
                return;
            }

            setButtonLoading(saveNameBtn, true);

            try {
                const response = await fetch('/api/user/name', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                const data = await response.json();

                if (data.success) {
                    currentUserName = name;
                    currentUserIp = data.ip;
                    nameInput.value = '';
                    updateUserDisplay();
                    showMessage('Name saved successfully!', 'success');
                    loadImages(); // Refresh to show new name
                    loadUsers(); // Refresh user list
                } else {
                    const errorMsg = getErrorMessage(data);
                    showMessage(`Error: ${errorMsg}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to save name: ${error.message}`, 'error');
            } finally {
                setButtonLoading(saveNameBtn, false);
            }
        }

        function setButtonLoading(button, loading) {
            if (loading) {
                button.disabled = true;
                const spinner = document.createElement('span');
                spinner.className = 'btn-spinner';
                button.insertBefore(spinner, button.firstChild);
            } else {
                button.disabled = false;
                const spinner = button.querySelector('.btn-spinner');
                if (spinner) spinner.remove();
            }
        }

        function openModal(image) {
            currentModalImage = image;
            currentImageFilename = image.filename;
            modalImage.src = `/uploads/${image.filename}`;
            modalImageName.textContent = image.filename;

            // Parse UTC timestamp and convert to local time
            const date = new Date(image.uploaded + 'Z');
            modalImageMeta.textContent = `${(image.size / 1024).toFixed(1)} KB â€¢ ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;

            const isMyImage = image.uploader_ip === currentUserIp;
            modalImageUploader.textContent = `Uploaded by: ${image.uploader_name}${isMyImage ? ' (You)' : ''}`;

            // Display EXIF data if available
            displayExifData(image.exif);

            // Render device checkboxes
            renderDeviceCheckboxes(image.allowed_devices || []);

            imageModal.classList.add('active');
        }

        function displayExifData(exif) {
            const exifSection = document.getElementById('exifSection');
            const exifDateTaken = document.getElementById('exifDateTaken');
            const exifCamera = document.getElementById('exifCamera');
            const exifLocation = document.getElementById('exifLocation');
            const exifDetails = document.getElementById('exifDetails');

            // Clear previous data
            exifDateTaken.innerHTML = '';
            exifCamera.innerHTML = '';
            exifLocation.innerHTML = '';
            exifDetails.innerHTML = '';

            // Check if we have any EXIF data
            if (!exif || (!exif.date_taken && !exif.camera_make && !exif.camera_model &&
                         !exif.gps_latitude && !exif.gps_longitude &&
                         (!exif.additional || Object.keys(exif.additional).length === 0))) {
                exifSection.style.display = 'none';
                return;
            }

            // Show the section
            exifSection.style.display = 'block';

            // Date taken
            if (exif.date_taken) {
                const dateTaken = new Date(exif.date_taken);
                exifDateTaken.innerHTML = `<strong>ðŸ“… Date Taken:</strong> ${dateTaken.toLocaleDateString()} ${dateTaken.toLocaleTimeString()}`;
            }

            // Camera info
            if (exif.camera_make || exif.camera_model) {
                let cameraText = '<strong>ðŸ“· Camera:</strong> ';
                if (exif.camera_make && exif.camera_model) {
                    cameraText += `${exif.camera_make} ${exif.camera_model}`;
                } else {
                    cameraText += exif.camera_make || exif.camera_model;
                }
                exifCamera.innerHTML = cameraText;
            }

            // GPS location
            if (exif.gps_latitude && exif.gps_longitude) {
                const lat = exif.gps_latitude.toFixed(6);
                const lon = exif.gps_longitude.toFixed(6);
                let locationText = `<strong>ðŸ“ Location:</strong> ${lat}, ${lon}`;

                // Add Google Maps link
                const mapsUrl = `https://www.google.com/maps?q=${lat},${lon}`;
                locationText += ` <a href="${mapsUrl}" target="_blank" style="color: #0066cc; text-decoration: none;">[View on Map]</a>`;

                if (exif.gps_altitude) {
                    locationText += `<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Altitude: ${Math.round(exif.gps_altitude)}m`;
                }
                exifLocation.innerHTML = locationText;
            }

            // Additional EXIF details
            if (exif.additional && Object.keys(exif.additional).length > 0) {
                const details = [];
                if (exif.additional.ExposureTime) details.push(`Exposure: ${exif.additional.ExposureTime}`);
                if (exif.additional.FNumber) details.push(`f/${exif.additional.FNumber}`);
                if (exif.additional.ISO) details.push(`ISO ${exif.additional.ISO}`);
                if (exif.additional.FocalLength) details.push(`${exif.additional.FocalLength}mm`);

                if (details.length > 0) {
                    exifDetails.innerHTML = `<strong>âš™ï¸ Settings:</strong> ${details.join(' â€¢ ')}`;
                }
            }
        }

        function closeModal() {
            imageModal.classList.remove('active');
            currentModalImage = null;
            currentImageFilename = null;
        }

        modalDisplayBtn.addEventListener('click', async () => {
            if (!currentModalImage) return;
            setButtonLoading(modalDisplayBtn, true);
            await displayImage(currentModalImage.filename);
            setButtonLoading(modalDisplayBtn, false);
            closeModal();
        });

        modalDeleteBtn.addEventListener('click', async () => {
            if (!currentModalImage) return;
            if (!confirm(`Delete ${currentModalImage.filename}?`)) return;

            setButtonLoading(modalDeleteBtn, true);
            await deleteImage(currentModalImage.filename);
            setButtonLoading(modalDeleteBtn, false);
            closeModal();
        });

        modalRotateLeftBtn.addEventListener('click', async () => {
            if (!currentModalImage) return;
            setButtonLoading(modalRotateLeftBtn, true);
            await rotateImage(currentModalImage.filename, 270);
            setButtonLoading(modalRotateLeftBtn, false);
        });

        modalRotate180Btn.addEventListener('click', async () => {
            if (!currentModalImage) return;
            setButtonLoading(modalRotate180Btn, true);
            await rotateImage(currentModalImage.filename, 180);
            setButtonLoading(modalRotate180Btn, false);
        });

        modalRotateRightBtn.addEventListener('click', async () => {
            if (!currentModalImage) return;
            setButtonLoading(modalRotateRightBtn, true);
            await rotateImage(currentModalImage.filename, 90);
            setButtonLoading(modalRotateRightBtn, false);
        });

        function showMessage(text, type) {
            message.textContent = text;
            message.className = `message ${type}`;
            message.style.display = 'block';
            setTimeout(() => {
                message.style.display = 'none';
            }, 5000);
        }

        // Helper function to extract error message from standardized API response
        function getErrorMessage(response) {
            // Handle new standardized format: {success: false, error: {message, code}}
            if (response && response.error) {
                if (typeof response.error === 'object' && response.error.message) {
                    return response.error.message;
                }
                // Fallback for old format where error is a string
                return response.error;
            }
            // Fallback for unknown format
            return 'An unknown error occurred';
        }

        async function loadImages() {
            loading.style.display = 'block';
            gallery.innerHTML = '';

            try {
                // Build URL with filter and pagination parameters
                const filterValue = userFilter.value;
                const searchValue = searchInput.value.trim();
                const deviceFilterValue = deviceFilter.value;
                const dateFromValue = dateFromInput.value;
                const dateToValue = dateToInput.value;
                const sortByValue = sortBySelect.value;

                let url = `/api/images?page=${currentPage}&limit=${itemsPerPage}`;

                if (filterValue === 'me' && currentUserIp) {
                    url += `&user=${encodeURIComponent(currentUserIp)}`;
                } else if (filterValue !== 'all' && filterValue !== 'me') {
                    // Filtering by specific user IP
                    url += `&user=${encodeURIComponent(filterValue)}`;
                }

                // Add search query if specified
                if (searchValue) {
                    url += `&search=${encodeURIComponent(searchValue)}`;
                }

                // Add device filter if specified
                if (deviceFilterValue && deviceFilterValue !== 'all') {
                    url += `&device=${encodeURIComponent(deviceFilterValue)}`;
                }

                // Add date range filters if specified
                if (dateFromValue) {
                    url += `&date_from=${encodeURIComponent(dateFromValue)}`;
                }
                if (dateToValue) {
                    url += `&date_to=${encodeURIComponent(dateToValue)}`;
                }

                // Add sort order
                if (sortByValue) {
                    url += `&sort_by=${encodeURIComponent(sortByValue)}`;
                }

                const response = await fetch(url);
                const data = await response.json();
                currentImage = data.current_image;

                loading.style.display = 'none';

                // Update pagination info if available
                if (data.total !== undefined) {
                    totalPages = data.pages || 1;
                    updatePaginationUI(data.total, data.page, data.pages);
                } else {
                    // No pagination data (backward compatibility)
                    paginationContainer.style.display = 'none';
                }

                if (data.images.length === 0) {
                    const filterMsg = filterValue === 'all' ? 'No images uploaded yet. Upload your first image above!' :
                                     filterValue === 'me' ? 'You haven\'t uploaded any images yet.' :
                                     'This user has no images.';
                    gallery.innerHTML = `<p style="text-align: center; color: #888;">${filterMsg}</p>`;
                    paginationContainer.style.display = 'none';
                    return;
                }

                data.images.forEach(image => {
                    const card = createImageCard(image);
                    gallery.appendChild(card);
                });

                // Initialize lazy loading for all images
                initLazyLoading();
            } catch (error) {
                loading.style.display = 'none';
                gallery.innerHTML = '<p style="text-align: center; color: #c92a2a;">Failed to load images</p>';
                paginationContainer.style.display = 'none';
            }
        }

        function updatePaginationUI(total, page, pages) {
            if (pages <= 1) {
                // Hide pagination if only one page or no images
                paginationContainer.style.display = 'none';
                return;
            }

            paginationContainer.style.display = 'flex';
            pageInfo.textContent = `Page ${page} of ${pages} (${total} images)`;

            // Disable/enable buttons based on current page
            prevPageBtn.disabled = (page <= 1);
            nextPageBtn.disabled = (page >= pages);
        }

        function goToPage(page) {
            currentPage = page;
            loadImages();
        }

        function nextPage() {
            if (currentPage < totalPages) {
                goToPage(currentPage + 1);
            }
        }

        function prevPage() {
            if (currentPage > 1) {
                goToPage(currentPage - 1);
            }
        }

        function createImageCard(image) {
            const card = document.createElement('div');
            card.className = 'image-card';
            if (image.filename === currentImage) {
                card.classList.add('current');
            }
            if (selectedImages.has(image.filename)) {
                card.classList.add('selected');
            }

            // Add checkbox for bulk selection
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'image-checkbox';
            checkbox.checked = selectedImages.has(image.filename);
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();  // Prevent card click
                toggleImageSelection(image.filename, card, checkbox);
            });
            card.appendChild(checkbox);

            // Make card clickable (except checkbox)
            card.addEventListener('click', (e) => {
                if (e.target !== checkbox) {
                    openModal(image);
                }
            });

            const img = document.createElement('img');
            img.className = 'image-thumbnail lazy-loading';
            img.dataset.src = `/api/thumbnails/${image.filename}?t=${lastRotationTimestamp}`;
            img.alt = image.filename;
            img.loading = 'lazy';  // Native lazy loading as fallback

            // Add load event to remove skeleton animation
            img.onload = () => {
                img.classList.remove('lazy-loading');
                img.classList.add('lazy-loaded');
            };

            const info = document.createElement('div');
            info.className = 'image-info';

            if (image.filename === currentImage) {
                const badge = document.createElement('div');
                badge.className = 'current-badge';
                badge.textContent = 'Currently Displayed';
                info.appendChild(badge);
            }

            // Show uploader badge
            const uploaderBadge = document.createElement('div');
            const isMyImage = image.uploader_ip === currentUserIp;
            uploaderBadge.className = isMyImage ? 'uploader-badge' : 'uploader-badge other';
            uploaderBadge.textContent = isMyImage ? 'You' : image.uploader_name;
            info.appendChild(uploaderBadge);

            const name = document.createElement('div');
            name.className = 'image-name';
            name.textContent = image.filename;

            info.appendChild(name);

            card.appendChild(img);
            card.appendChild(info);

            return card;
        }

        // Lazy loading with Intersection Observer
        function initLazyLoading() {
            // Check if Intersection Observer is supported
            if ('IntersectionObserver' in window) {
                const imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            // Load the image
                            if (img.dataset.src) {
                                img.src = img.dataset.src;
                                delete img.dataset.src;
                            }
                            // Stop observing this image
                            observer.unobserve(img);
                        }
                    });
                }, {
                    // Start loading images 50px before they enter the viewport
                    rootMargin: '50px',
                    threshold: 0.01
                });

                // Observe all images with data-src attribute
                const lazyImages = document.querySelectorAll('img[data-src]');
                lazyImages.forEach(img => imageObserver.observe(img));
            } else {
                // Fallback for browsers without Intersection Observer support
                // Just load all images immediately
                const lazyImages = document.querySelectorAll('img[data-src]');
                lazyImages.forEach(img => {
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        delete img.dataset.src;
                    }
                });
            }
        }

        async function displayImage(filename) {
            try {
                showMessage(`Displaying ${filename} on e-paper...`, 'success');
                const response = await fetch(`/api/display/${filename}`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('Image displayed successfully!', 'success');
                    loadImages();
                } else {
                    showMessage(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to display image: ${error.message}`, 'error');
            }
        }

        async function deleteImage(filename) {
            if (!confirm(`Delete ${filename}?`)) return;

            try {
                const response = await fetch(`/api/delete/${filename}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('Image deleted successfully', 'success');
                    loadImages();
                    loadUsers(); // Refresh user list
                    loadStorageInfo(); // Refresh storage info
                } else {
                    showMessage(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to delete image: ${error.message}`, 'error');
            }
        }

        async function rotateImage(filename, angle) {
            try {
                showMessage(`Rotating image ${angle}Â°...`, 'success');
                const response = await fetch(`/api/images/${filename}/rotate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ angle })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage(`Image rotated ${angle}Â° successfully!`, 'success');

                    // Update rotation timestamp for cache busting
                    lastRotationTimestamp = Date.now();

                    // Reload the modal image with cache busting to show rotated version
                    modalImage.src = `/uploads/${filename}?t=${lastRotationTimestamp}`;

                    // Refresh the gallery to show updated thumbnail
                    loadImages();
                } else {
                    const errorMsg = getErrorMessage(data);
                    showMessage(`Error: ${errorMsg}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to rotate image: ${error.message}`, 'error');
            }
        }

        async function loadUsers() {
            try {
                const response = await fetch('/api/users');
                const data = await response.json();

                // Store the current filter value
                const currentFilter = userFilter.value;

                // Clear existing options except the first two
                while (userFilter.options.length > 2) {
                    userFilter.remove(2);
                }

                // Add each user as an option
                data.users.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.ip;
                    const displayName = user.name !== user.ip ? user.name : user.ip;
                    option.textContent = `${displayName} (${user.image_count} ${user.image_count === 1 ? 'photo' : 'photos'})`;
                    userFilter.appendChild(option);
                });

                // Restore the previous filter selection if it still exists
                if (currentFilter !== 'all' && currentFilter !== 'me') {
                    const optionExists = Array.from(userFilter.options).some(opt => opt.value === currentFilter);
                    if (optionExists) {
                        userFilter.value = currentFilter;
                    }
                }
            } catch (error) {
                console.error('Failed to load users:', error);
            }
        }

        async function loadServerInfo() {
            try {
                const response = await fetch('/api/server-info');
                const data = await response.json();

                ipList.innerHTML = '';

                if (data.local_ip && data.local_ip !== 'Unable to detect') {
                    const localUrl = `http://${data.local_ip}:${data.port}`;
                    ipList.appendChild(createIPItem('Local Network', localUrl));
                }

                if (data.tailscale_ip && data.tailscale_ip !== 'Not available') {
                    const tailscaleUrl = `http://${data.tailscale_ip}:${data.port}`;
                    ipList.appendChild(createIPItem('Tailscale', tailscaleUrl));
                }

                if (ipList.children.length === 0) {
                    ipList.innerHTML = '<p style="color: #888;">Server info unavailable</p>';
                }
            } catch (error) {
                console.error('Failed to load server info:', error);
                ipList.innerHTML = '<p style="color: #888;">Failed to load server info</p>';
            }
        }

        function createIPItem(label, url) {
            const item = document.createElement('div');
            item.className = 'ip-item';

            const labelEl = document.createElement('span');
            labelEl.className = 'ip-label';
            labelEl.textContent = label + ':';

            const valueEl = document.createElement('span');
            valueEl.className = 'ip-value';
            valueEl.textContent = url;

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(url).then(() => {
                    copyBtn.textContent = 'Copied!';
                    copyBtn.classList.add('copied');
                    setTimeout(() => {
                        copyBtn.textContent = 'Copy';
                        copyBtn.classList.remove('copied');
                    }, 2000);
                });
            });

            item.appendChild(labelEl);
            item.appendChild(valueEl);
            item.appendChild(copyBtn);

            return item;
        }

        // Device Management Functions

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function loadDevices() {
            try {
                const response = await fetch('/api/devices');
                const data = await response.json();
                allDevices = data.devices || [];

                if (allDevices.length === 0) {
                    devicesList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No devices registered yet</p>';
                } else {
                    devicesList.innerHTML = '';
                    allDevices.forEach(device => {
                        const deviceItem = createDeviceItem(device);
                        devicesList.appendChild(deviceItem);
                    });
                }

                // Populate device filter dropdown
                const currentDeviceFilter = deviceFilter.value;  // Remember current selection
                deviceFilter.innerHTML = '<option value="all">All Devices</option>';
                allDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.device_id;
                    option.textContent = device.name;
                    deviceFilter.appendChild(option);
                });
                // Restore previous selection if it still exists
                if (currentDeviceFilter && currentDeviceFilter !== 'all') {
                    const optionExists = Array.from(deviceFilter.options).some(opt => opt.value === currentDeviceFilter);
                    if (optionExists) {
                        deviceFilter.value = currentDeviceFilter;
                    }
                }

                // Update upload device selection list if it's visible
                const uploadDeviceSelection = document.getElementById('uploadDeviceSelection');
                if (uploadDeviceSelection && uploadDeviceSelection.style.display !== 'none') {
                    populateUploadDevicesList();
                }
            } catch (error) {
                console.error('Failed to load devices:', error);
                devicesList.innerHTML = '<p style="color: #f44336; text-align: center; padding: 20px;">Failed to load devices</p>';
            }
        }

        function createDeviceItem(device) {
            const item = document.createElement('div');
            item.className = 'device-item';

            const info = document.createElement('div');
            info.className = 'device-info';

            const nameEl = document.createElement('div');
            nameEl.className = 'device-name';
            const typeBadge = document.createElement('span');
            typeBadge.className = 'device-type-badge';
            typeBadge.textContent = device.device_type || 'display';
            nameEl.appendChild(typeBadge);
            nameEl.appendChild(document.createTextNode(device.name));

            const metaEl = document.createElement('div');
            metaEl.className = 'device-meta';
            // Parse UTC timestamps and convert to local time
            const registered = new Date(device.registered + 'Z').toLocaleDateString();
            const lastSeen = new Date(device.last_seen + 'Z').toLocaleString();
            metaEl.innerHTML = `Registered: ${registered} | Last seen: ${lastSeen}`;

            const idEl = document.createElement('div');
            idEl.className = 'device-id';
            const isMobile = window.innerWidth <= 768;
            const shortId = device.device_id.substring(0, 8) + '...';
            idEl.textContent = `ID: ${isMobile ? shortId : device.device_id}`;
            idEl.dataset.fullId = device.device_id;
            idEl.dataset.shortId = shortId;
            idEl.dataset.expanded = 'false';
            idEl.title = 'Click to toggle full ID';

            // Add click handler to toggle full UUID on mobile
            idEl.addEventListener('click', function() {
                if (this.dataset.expanded === 'false') {
                    this.textContent = `ID: ${this.dataset.fullId}`;
                    this.dataset.expanded = 'true';
                    this.classList.add('expanded');
                } else {
                    const isMobile = window.innerWidth <= 768;
                    this.textContent = `ID: ${isMobile ? this.dataset.shortId : this.dataset.fullId}`;
                    this.dataset.expanded = 'false';
                    this.classList.remove('expanded');
                }
            });

            info.appendChild(nameEl);
            info.appendChild(metaEl);
            info.appendChild(idEl);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-danger btn-small';
            deleteBtn.textContent = 'Delete';
            deleteBtn.addEventListener('click', () => deleteDevice(device.device_id));

            item.appendChild(info);
            item.appendChild(deleteBtn);

            return item;
        }

        async function addDevice() {
            const name = deviceNameInput.value.trim();
            if (!name) {
                showMessage('Please enter a device name', 'error');
                return;
            }

            const deviceId = generateUUID();

            try {
                const response = await fetch('/api/devices/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_id: deviceId,
                        name: name,
                        device_type: 'display'
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage(`Device "${name}" added successfully`, 'success');
                    deviceNameInput.value = '';
                    await loadDevices();
                } else {
                    showMessage(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to add device: ${error.message}`, 'error');
            }
        }

        async function deleteDevice(deviceId) {
            if (!confirm('Are you sure you want to delete this device?')) {
                return;
            }

            try {
                const response = await fetch(`/api/devices/${deviceId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('Device deleted successfully', 'success');
                    await loadDevices();
                } else {
                    showMessage(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to delete device: ${error.message}`, 'error');
            }
        }

        // Storage Info Functions
        async function loadStorageInfo() {
            try {
                const response = await fetch('/api/storage');
                const result = await response.json();

                if (result.success) {
                    const data = result.data;
                    const storageInfo = document.getElementById('storageInfo');
                    const storageText = document.getElementById('storageText');
                    const storageBar = document.getElementById('storageBar');

                    // Update text
                    storageText.textContent = `${data.total_formatted} / ${data.quota_formatted} (${data.image_count} images)`;

                    // Update progress bar
                    const percent = Math.min(100, data.quota_used_percent);
                    storageBar.style.width = `${percent}%`;
                    storageBar.textContent = `${percent.toFixed(1)}%`;

                    // Show/hide warning state
                    if (data.is_warning) {
                        storageInfo.classList.add('warning');
                    } else {
                        storageInfo.classList.remove('warning');
                    }

                    // Show the storage info
                    storageInfo.style.display = 'block';
                } else {
                    console.error('Failed to load storage info:', result.error);
                }
            } catch (error) {
                console.error('Failed to load storage info:', error);
            }
        }

        // Upload Device Selection Functions
        function populateUploadDevicesList() {
            const uploadDevicesList = document.getElementById('uploadDevicesList');
            uploadDevicesList.innerHTML = '';

            if (allDevices.length === 0) {
                uploadDevicesList.innerHTML = '<p style="color: #888; padding: 10px; margin: 0; font-size: 0.9em;">No devices registered yet. Add a device below first.</p>';
                return;
            }

            // Load saved device preferences
            const savedPreferences = loadDevicePreferences();

            allDevices.forEach(device => {
                const label = document.createElement('label');
                label.style.cssText = 'display: flex; align-items: center; gap: 10px; cursor: pointer; color: #333; padding: 10px; background: #f8f9fa; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'upload-device-checkbox';
                checkbox.value = device.device_id;
                checkbox.style.cssText = 'cursor: pointer; width: 18px; height: 18px;';

                // Pre-select checkbox if it was previously selected
                if (savedPreferences.includes(device.device_id)) {
                    checkbox.checked = true;
                }

                const span = document.createElement('span');
                span.style.cssText = 'font-weight: 600; font-size: 0.95em;';
                span.textContent = `${device.name}`;

                label.appendChild(checkbox);
                label.appendChild(span);

                // Add hover effect
                label.addEventListener('mouseenter', () => {
                    label.style.background = '#e8f5e9';
                    label.style.borderColor = '#14b8a6';
                });
                label.addEventListener('mouseleave', () => {
                    label.style.background = '#f8f9fa';
                    label.style.borderColor = 'transparent';
                });

                uploadDevicesList.appendChild(label);
            });

            // Update "Select All" checkbox state after populating
            updateSelectAllCheckbox();
        }

        function updateSelectAllCheckbox() {
            const selectAllDisplays = document.getElementById('selectAllDisplays');
            if (selectAllDisplays) {
                const allCheckboxes = document.querySelectorAll('.upload-device-checkbox');
                const checkedCheckboxes = document.querySelectorAll('.upload-device-checkbox:checked');
                selectAllDisplays.checked = allCheckboxes.length > 0 && allCheckboxes.length === checkedCheckboxes.length;
            }
        }

        function getSelectedUploadDevices() {
            const checkboxes = document.querySelectorAll('.upload-device-checkbox:checked');
            const selectedDevices = Array.from(checkboxes).map(cb => cb.value);

            // Save device selection to localStorage for future uploads
            saveDevicePreferences(selectedDevices);

            return selectedDevices;
        }

        function saveDevicePreferences(deviceIds) {
            try {
                localStorage.setItem('frameSync_preferredDevices', JSON.stringify(deviceIds));
            } catch (error) {
                console.warn('Failed to save device preferences to localStorage:', error);
            }
        }

        function loadDevicePreferences() {
            try {
                const saved = localStorage.getItem('frameSync_preferredDevices');
                return saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.warn('Failed to load device preferences from localStorage:', error);
                return [];
            }
        }

        function clearDevicePreferences() {
            try {
                localStorage.removeItem('frameSync_preferredDevices');
                showMessage('Device preferences cleared!', 'success');

                // Uncheck all device checkboxes
                const checkboxes = document.querySelectorAll('.upload-device-checkbox');
                checkboxes.forEach(cb => cb.checked = false);

                // Update select all checkbox
                const selectAllDisplays = document.getElementById('selectAllDisplays');
                if (selectAllDisplays) {
                    selectAllDisplays.checked = false;
                }
            } catch (error) {
                console.warn('Failed to clear device preferences:', error);
            }
        }

        function setupUploadDeviceSelection() {
            const selectAllDisplays = document.getElementById('selectAllDisplays');
            const uploadDeviceSelection = document.getElementById('uploadDeviceSelection');

            // Show device selection when file is selected
            const fileInput = document.getElementById('fileInput');
            const originalChangeHandler = fileInput.onchange;

            // Handle select all checkbox
            selectAllDisplays.addEventListener('change', (e) => {
                const checkboxes = document.querySelectorAll('.upload-device-checkbox');
                checkboxes.forEach(cb => {
                    cb.checked = e.target.checked;
                });
            });

            // Update select all checkbox when individual checkboxes change
            document.getElementById('uploadDevicesList').addEventListener('change', (e) => {
                if (e.target.classList.contains('upload-device-checkbox')) {
                    const allCheckboxes = document.querySelectorAll('.upload-device-checkbox');
                    const checkedCheckboxes = document.querySelectorAll('.upload-device-checkbox:checked');
                    selectAllDisplays.checked = allCheckboxes.length > 0 && allCheckboxes.length === checkedCheckboxes.length;
                }
            });
        }

        function renderDeviceCheckboxes(allowedDevices = []) {
            modalDevicesList.innerHTML = '';

            if (allDevices.length === 0) {
                modalDevicesList.innerHTML = '<p style="color: #888; padding: 10px;">No devices available. Add a device first.</p>';
                return;
            }

            allDevices.forEach(device => {
                const item = document.createElement('div');
                item.className = 'device-checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `device-${device.device_id}`;
                checkbox.value = device.device_id;
                checkbox.checked = allowedDevices.includes(device.device_id);

                const label = document.createElement('label');
                label.className = 'device-checkbox-label';
                label.htmlFor = `device-${device.device_id}`;
                label.textContent = `${device.name} (${device.device_type})`;

                item.appendChild(checkbox);
                item.appendChild(label);

                item.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                });

                modalDevicesList.appendChild(item);
            });
        }

        async function saveImageDevices() {
            if (!currentImageFilename) {
                showMessage('No image selected', 'error');
                return;
            }

            const checkboxes = modalDevicesList.querySelectorAll('input[type="checkbox"]');
            const allowedDevices = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);

            try {
                const response = await fetch(`/api/images/${currentImageFilename}/devices`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ allowed_devices: allowedDevices })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('Device permissions updated', 'success');
                    await loadImages();
                } else {
                    showMessage(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to update devices: ${error.message}`, 'error');
            }
        }

        // Bulk operation functions
        function toggleImageSelection(filename, card, checkbox) {
            if (selectedImages.has(filename)) {
                selectedImages.delete(filename);
                card.classList.remove('selected');
                checkbox.checked = false;
            } else {
                selectedImages.add(filename);
                card.classList.add('selected');
                checkbox.checked = true;
            }
            updateBulkToolbar();
        }

        function updateBulkToolbar() {
            const count = selectedImages.size;
            if (count > 0) {
                bulkToolbar.classList.add('active');
                bulkToolbarLabel.textContent = `${count} image${count > 1 ? 's' : ''} selected`;
            } else {
                bulkToolbar.classList.remove('active');
            }
        }

        function selectAllImages() {
            const cards = gallery.querySelectorAll('.image-card');
            cards.forEach(card => {
                const checkbox = card.querySelector('.image-checkbox');
                const img = card.querySelector('img');
                const filename = img.alt;
                selectedImages.add(filename);
                card.classList.add('selected');
                checkbox.checked = true;
            });
            updateBulkToolbar();
        }

        function deselectAllImages() {
            selectedImages.clear();
            const cards = gallery.querySelectorAll('.image-card');
            cards.forEach(card => {
                card.classList.remove('selected');
                const checkbox = card.querySelector('.image-checkbox');
                checkbox.checked = false;
            });
            updateBulkToolbar();
        }

        async function bulkDeleteImages() {
            if (selectedImages.size === 0) {
                showMessage('No images selected', 'error');
                return;
            }

            const count = selectedImages.size;
            if (!confirm(`Delete ${count} selected image${count > 1 ? 's' : ''}?`)) {
                return;
            }

            setButtonLoading(bulkDeleteBtn, true);

            try {
                const response = await fetch('/api/images/bulk-delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filenames: Array.from(selectedImages) })
                });

                const data = await response.json();

                if (data.success) {
                    const deletedCount = data.data?.deleted_count || 0;
                    showMessage(`Successfully deleted ${deletedCount} image${deletedCount > 1 ? 's' : ''}`, 'success');
                    selectedImages.clear();
                    updateBulkToolbar();
                    await loadImages();
                    await loadStorageInfo();
                } else {
                    const errorMsg = getErrorMessage(data);
                    showMessage(`Error: ${errorMsg}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to delete images: ${error.message}`, 'error');
            } finally {
                setButtonLoading(bulkDeleteBtn, false);
            }
        }

        function openBulkDeviceModal() {
            if (selectedImages.size === 0) {
                showMessage('No images selected', 'error');
                return;
            }

            bulkSelectionCount.textContent = selectedImages.size;
            renderBulkDeviceCheckboxes();
            bulkDeviceModal.classList.add('active');
        }

        function closeBulkDeviceModal() {
            bulkDeviceModal.classList.remove('active');
        }

        function renderBulkDeviceCheckboxes() {
            bulkDevicesList.innerHTML = '';

            if (allDevices.length === 0) {
                bulkDevicesList.innerHTML = '<p style="color: #888; padding: 10px;">No devices available. Add a device first.</p>';
                return;
            }

            allDevices.forEach(device => {
                const item = document.createElement('div');
                item.className = 'device-checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `bulk-device-${device.device_id}`;
                checkbox.value = device.device_id;
                checkbox.checked = false;  // Default unchecked

                const label = document.createElement('label');
                label.className = 'device-checkbox-label';
                label.htmlFor = `bulk-device-${device.device_id}`;
                label.textContent = `${device.name} (${device.device_type})`;

                item.appendChild(checkbox);
                item.appendChild(label);

                item.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                });

                bulkDevicesList.appendChild(item);
            });
        }

        async function saveBulkDevices() {
            if (selectedImages.size === 0) {
                showMessage('No images selected', 'error');
                closeBulkDeviceModal();
                return;
            }

            const checkboxes = bulkDevicesList.querySelectorAll('input[type="checkbox"]');
            const allowedDevices = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);

            setButtonLoading(bulkDeviceModalSave, true);

            try {
                const response = await fetch('/api/images/bulk-update-devices', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filenames: Array.from(selectedImages),
                        allowed_devices: allowedDevices
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const updatedCount = data.data?.updated_count || 0;
                    showMessage(`Updated devices for ${updatedCount} image${updatedCount > 1 ? 's' : ''}`, 'success');
                    selectedImages.clear();
                    updateBulkToolbar();
                    closeBulkDeviceModal();
                    await loadImages();
                } else {
                    const errorMsg = getErrorMessage(data);
                    showMessage(`Error: ${errorMsg}`, 'error');
                }
            } catch (error) {
                showMessage(`Failed to update devices: ${error.message}`, 'error');
            } finally {
                setButtonLoading(bulkDeviceModalSave, false);
            }
        }

        // Bulk operation event listeners
        selectAllBtn.addEventListener('click', selectAllImages);
        deselectAllBtn.addEventListener('click', deselectAllImages);
        bulkDeleteBtn.addEventListener('click', bulkDeleteImages);
        bulkChangeDevicesBtn.addEventListener('click', openBulkDeviceModal);
        bulkDeviceModalClose.addEventListener('click', closeBulkDeviceModal);
        bulkDeviceModalCancel.addEventListener('click', closeBulkDeviceModal);
        bulkDeviceModalSave.addEventListener('click', saveBulkDevices);
        bulkDeviceModal.addEventListener('click', (e) => {
            if (e.target === bulkDeviceModal) closeBulkDeviceModal();
        });

        async function initializeApp() {
            // Load initial images
            await loadImages();

            // Load users and check for current user's name
            await loadUsers();

            // Load devices
            await loadDevices();

            // Load storage info
            await loadStorageInfo();

            // Setup upload device selection
            setupUploadDeviceSelection();

            // Load server info for footer
            await loadServerInfo();

            // Try to detect current user from existing images
            try {
                const usersResponse = await fetch('/api/users');
                const usersData = await usersResponse.json();

                const imagesResponse = await fetch('/api/images');
                const imagesData = await imagesResponse.json();

                // If there's only one user and they have images, assume that's the current user
                if (usersData.users.length === 1 && imagesData.images.length > 0) {
                    const user = usersData.users[0];
                    currentUserIp = user.ip;
                    if (user.name !== user.ip) {
                        currentUserName = user.name;
                    }
                    updateUserDisplay();
                } else {
                    currentUserIpEl.textContent = 'Your identity will be shown after first upload';
                }
            } catch (err) {
                console.error('Failed to initialize user:', err);
                currentUserIpEl.textContent = 'Your identity will be shown after first upload';
            }
        }

        // Add filter change listener
        userFilter.addEventListener('change', () => {
            currentPage = 1;  // Reset to first page when filter changes
            loadImages();
        });

        // Add search and filter event listeners
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            // Debounce search to avoid excessive requests
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentPage = 1;  // Reset to first page when search changes
                loadImages();
            }, 300);  // Wait 300ms after user stops typing
        });

        deviceFilter.addEventListener('change', () => {
            currentPage = 1;  // Reset to first page when filter changes
            loadImages();
        });

        sortBySelect.addEventListener('change', () => {
            currentPage = 1;  // Reset to first page when sort order changes
            loadImages();
        });

        dateFromInput.addEventListener('change', () => {
            currentPage = 1;  // Reset to first page when filter changes
            loadImages();
        });

        dateToInput.addEventListener('change', () => {
            currentPage = 1;  // Reset to first page when filter changes
            loadImages();
        });

        clearFiltersBtn.addEventListener('click', () => {
            // Clear all filters
            searchInput.value = '';
            deviceFilter.value = 'all';
            sortBySelect.value = 'upload_time';
            dateFromInput.value = '';
            dateToInput.value = '';
            userFilter.value = 'all';
            currentPage = 1;
            loadImages();
        });

        // Pagination event listeners
        prevPageBtn.addEventListener('click', prevPage);
        nextPageBtn.addEventListener('click', nextPage);

        // Device management event listeners
        addDeviceBtn.addEventListener('click', addDevice);
        modalSaveDevicesBtn.addEventListener('click', saveImageDevices);
        deviceNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addDevice();
            }
        });

        // Upload confirmation buttons
        document.getElementById('confirmUploadBtn').addEventListener('click', () => {
            if (pendingFiles && pendingFiles.length > 0) {
                handleFiles(pendingFiles);
            }
        });

        document.getElementById('cancelUploadBtn').addEventListener('click', () => {
            // Hide device selection UI and clear pending files
            const uploadDeviceSelection = document.getElementById('uploadDeviceSelection');
            uploadDeviceSelection.style.display = 'none';
            pendingFiles = null;
            fileInput.value = '';
        });

        // Clear device preferences button
        document.getElementById('clearPreferencesBtn').addEventListener('click', (e) => {
            e.preventDefault();
            clearDevicePreferences();
        });

        // Initialize app on page load
        initializeApp();

        // Auto-refresh every 30 seconds
        setInterval(() => {
            loadImages();
            loadUsers();
            loadDevices();
        }, 30000);
    </script>
</body>
</html>
